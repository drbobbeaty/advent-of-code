# Advent of Code

Just my solutions to the problems at [Advent of Code](https://adventofcode.com),
which a [friend](https://github.com/hby/) introduced me to in 2015. It has been
a fun way to push the usage of Clojure to stateful, and more traditionally
mutable domain problems.

## 2015

This was my first year and I made it all the way to Day 21 - it was a lot of
fun to do some of these days. And I have to admit that Clojure was just a great
tool to get a lot of these puzzles done.

## 2016

This year I was a little _busier_ and I only got to Day 8 - and I know it was
just that I _wanted_ to do it, but a lot of the puzzles had state in them, and
that wasn't a great fit for Clojure. But it was still fun to work these with
a friend.

I ended up finishing up a lot of this year while doing 2018, so a lot more
of this is filled in. Good enough. :)

## 2017

This I didn't really get started on, and I feel kinda bad about that. But I'm
hoping to take some time and really see if I can do a few of these while I'm
also working on this year's puzzles.

Looking pretty good - up to Day 20, and I'll keep working on these as I have
time.

Finished all 25 days! This was a really impressive run for me - didn't have
to skip a day - just one to the next, and then on we go. Not bad. :)

## 2018

I got more done this year than I expected. I didn't get three pathing problems
done, and I have looked at the solutions for some, and they make no sense, so
I think I'm going to have to figure this out by reading and working on a few
ideas. But still... this is a lot better than I've done in the past.

## 2019

I got stuck on Day 18 and Day 20 - both because of computational complexity.
Both were pathing problems, and I really had to buck up and learn Dijkstra's as
well as the Breadth-First Search that does things differently, but can be used
to find distances in mazes, etc. I'm glad I pushed through and learned these
two concepts by beating on them - I'm a better coder because of it.

The other days were not too bad, and while it took a few extra days to get
Day 18 and Day 20, it was *_really_* worth it.

## 2020

I got stuck on Day 19, Day 20, and Day 23 - either because of computational
complexity, or just lack of interest in solving the puzzle. The missing sea
monster was a pattern matcher, and that's OK... but not exciting. And the
large `n` problems are just not what I enjoy doing.

The other days were not too bad.

## 2021

This was an interesting year, as there were two days: Day 21 and 22, that
were computationally intensive if you tried to brute force them. They took
clever thought, and then they cracked. And Day 23 was simpler to solve by hand
than to try and code it up. And Day 24 was really a disassembly problem that
lead to what the code was doing. Then the solution was very simple - so on
Days 23 and 24, not a lot of _coding_, but that's OK - they would have been
horrible to try and code up, or execute.

But this year it was 25 Days in 25 days. Very fun.

## License

Copyright Â© 2015-2019 Bob Beaty

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
